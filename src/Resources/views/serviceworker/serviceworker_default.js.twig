let CACHE = 'cache-sw-{{ alias }}-{{ version }}';

{% block install %}
self.addEventListener('install', function(e) {
    e.waitUntil(
        caches.open(CACHE).then(function(cache) {
            {% if debug|default(false) %}console.log('[Serviceworker] Install: Cache open');{% endif %}
            // Fetch webpack manifest file
            return fetch('/build/manifest.json').then(function(responce) {
                return responce.json();
            }).then(function(json) {
                {% if debug|default(false) %}console.log('[Serviceworker] Install: Fetched manifest');{% endif %}
                // Create an array with only file paths
                let files = Object.keys(json).map(function(key) {
                    return json[key];
                });
                // Cache webpack assets from generated file list
                return cache.addAll(files).then(function () {
                    // Remove old caches
                    caches.keys().then(function(names) {
                        return Promise.all(names.filter(function(name) {
                            return name !== CACHE;
                        }).map(function(name) {
                            return caches.delete(name)
                        }))
                    })
                });
            });
        }).then(function() {
            {% if debug|default(false) %}console.log('[Serviceworker] Install: Skip waiting');{% endif %}
            return self.skipWaiting();
        })
    );
});
{% endblock %}

{% block activate %}
self.addEventListener('activate', function(event) {
    {% if debug|default(false) %} console.log('[Serviceworker] Activate event!');{% endif %}
    event.waitUntil(self.clients.claim());
});
{% endblock %}

{% block fetch %}
self.addEventListener('fetch', function(event) {
    {% if debug|default(false) %}console.log('[Serviceworker] Fetch: '.event.request.url);{% endif %}
    var url = new URL(event.request.url);

    // don't cache backend or dev routes
    if (url.pathname.match('^\/contao')
        || url.pathname.match('^\/_contao')
        || url.pathname.match('^\/app_dev.php')
        || url.pathname.match('^\/api')
    ) {
        {% if debug|default(false) %}console.log('[Serviceworker] Fetch: Stop (' + event.request.url + ')');{% endif %}
        return false;
    }

    event.respondWith(fromNetwork(event.request, 600).catch(function () {
        {% if debug|default(false) %}console.log('[Serviceworker] Fetch: Catch error with cache');{% endif %}
        return fromCache(event.request).catch(function() {
            return useFallback();
        });
    }));
});

{% endblock %}

{% block push %}
    {% if supportPush|default(false) %}
    self.addEventListener('push', function(event) {
        let payload = event.data ? event.data.text() : false;
        if (false === payload)
        {
            {% if debug|default(false) %}console.log("[Serviceworker] Push: A push notification sent from {{ pageTitle }} without any content.");{% endif %}
            return;
        }
        {% if debug|default(false) %}console.log("[Serviceworker] Push: Payload: ", payload);{% endif %}
        payload = JSON.parse(payload);

        event.waitUntil(
            self.registration.showNotification("{{ pageTitle }}", payload)
        );
    });


        {% block noticiationclick %}
        self.addEventListener('notificationclick', function(event) {
            {% if debug|default(false) %}console.log("[Serviceworker] Notificationclick event ");{% endif %}
            if (event.notification.data.clickJumpTo !== undefined)
            {
                event.notification.close();
                event.waitUntil(
                    clients.openWindow(event.notification.data.clickJumpTo)
                );
            }
        });
        {% endblock %}
    {% endif %}
{% endblock %}

{% block fromNetwork %}
function fromNetwork(request, timeout) {
    {% if debug|default(false) %}console.log('[Serviceworker] Fetch: Try fetch from network'); {% endif %}
    return new Promise(function (fulfill, reject) {
        var timeoutId = setTimeout(reject, timeout);
        fetch(request).then(function (response) {
            clearTimeout(timeoutId);
            caches.open(CACHE).then(function(cache){
                cache.put(request, response.clone());
                fulfill(response);
            });
        }, reject);
    });
}
{% endblock %}

{% block fromCache %}
function fromCache(request) {
    {% if debug|default(false) %}console.log('[Serviceworker] Fetch: Try fetch from cache');{% endif %}
    return caches.open(CACHE).then(function (cache) {
        return cache.match(request).then(function (matching) {
            {% if debug|default(false) %}console.log('[Serviceworker] Fetch: Return result from cache');{% endif %}
            return matching || Promise.reject('no-match');
        });
    });
}
{% endblock %}

{% block fallback %}
const FALLBACK =
    '<svg xmlns="http://www.w3.org/2000/svg" width="200" height="180" stroke-linejoin="round">' +
    '  <path stroke="#DDD" stroke-width="25" d="M99,18 15,162H183z"/>' +
    '  <path stroke-width="17" fill="#FFF" d="M99,18 15,162H183z" stroke="#eee"/>' +
    '  <path d="M91,70a9,9 0 0,1 18,0l-5,50a4,4 0 0,1-8,0z" fill="#aaa"/>' +
    '  <circle cy="138" r="9" cx="100" fill="#aaa"/>' +
    '</svg>';

function useFallback() {
    {% if debug|default(false) %}console.log('[Serviceworker] Fetch: Use Fallback');{% endif %}
    return Promise.resolve(new Response(FALLBACK, { headers: {
            'Content-Type': 'image/svg+xml'
        }}));
}
{% endblock %}